{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "X的维度为: (2, 400)\n",
      "Y的维度为: (1, 400)\n",
      "数据集里面的数据有：400 个\n",
      "第  0  次循环，成本为：0.6930480201239823\n",
      "第  1000  次循环，成本为：0.3098018601352803\n",
      "第  2000  次循环，成本为：0.2924326333792646\n",
      "第  3000  次循环，成本为：0.2833492852647411\n",
      "第  4000  次循环，成本为：0.27678077562979253\n",
      "第  5000  次循环，成本为：0.2634715508859307\n",
      "第  6000  次循环，成本为：0.24204413129940758\n",
      "第  7000  次循环，成本为：0.23552486626608762\n",
      "第  8000  次循环，成本为：0.23140964509854278\n",
      "第  9000  次循环，成本为：0.22846408048352362\n"
     ]
    },
    {
     "ename": "ValueError",
     "evalue": "'c' argument has 1 elements, which is not acceptable for use with 'x' with size 400, 'y' with size 400.",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\colors.py\u001b[0m in \u001b[0;36mto_rgba\u001b[1;34m(c, alpha)\u001b[0m\n\u001b[0;32m    173\u001b[0m     \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 174\u001b[1;33m         \u001b[0mrgba\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_colors_full_map\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcache\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mc\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    175\u001b[0m     \u001b[1;32mexcept\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mKeyError\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# Not in cache, or unhashable.\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mTypeError\u001b[0m: unhashable type: 'numpy.ndarray'",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\axes\\_axes.py\u001b[0m in \u001b[0;36mscatter\u001b[1;34m(self, x, y, s, c, marker, cmap, norm, vmin, vmax, alpha, linewidths, verts, edgecolors, **kwargs)\u001b[0m\n\u001b[0;32m   4231\u001b[0m             \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# Then is 'c' acceptable as PathCollection facecolors?\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 4232\u001b[1;33m                 \u001b[0mcolors\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mmcolors\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mto_rgba_array\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mc\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   4233\u001b[0m                 \u001b[0mn_elem\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mcolors\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mshape\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\colors.py\u001b[0m in \u001b[0;36mto_rgba_array\u001b[1;34m(c, alpha)\u001b[0m\n\u001b[0;32m    274\u001b[0m     \u001b[1;32mfor\u001b[0m \u001b[0mi\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mcc\u001b[0m \u001b[1;32min\u001b[0m \u001b[0menumerate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mc\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 275\u001b[1;33m         \u001b[0mresult\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mi\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mto_rgba\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mcc\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    276\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[0mresult\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\colors.py\u001b[0m in \u001b[0;36mto_rgba\u001b[1;34m(c, alpha)\u001b[0m\n\u001b[0;32m    175\u001b[0m     \u001b[1;32mexcept\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mKeyError\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# Not in cache, or unhashable.\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 176\u001b[1;33m         \u001b[0mrgba\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_to_rgba_no_colorcycle\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mc\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    177\u001b[0m         \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\colors.py\u001b[0m in \u001b[0;36m_to_rgba_no_colorcycle\u001b[1;34m(c, alpha)\u001b[0m\n\u001b[0;32m    230\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mc\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32min\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;36m3\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m4\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 231\u001b[1;33m         \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"RGBA sequence should have length 3 or 4\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    232\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mc\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;36m3\u001b[0m \u001b[1;32mand\u001b[0m \u001b[0malpha\u001b[0m \u001b[1;32mis\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mValueError\u001b[0m: RGBA sequence should have length 3 or 4",
      "\nDuring handling of the above exception, another exception occurred:\n",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-2-31d8555d5e90>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m    244\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    245\u001b[0m \u001b[1;31m#绘制边界\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 246\u001b[1;33m \u001b[0mplot_decision_boundary\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;32mlambda\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m:\u001b[0m \u001b[0mpredict\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mparameters\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mT\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mX\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mY\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    247\u001b[0m \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mtitle\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"Decision Boundary for hidden layer size \"\u001b[0m \u001b[1;33m+\u001b[0m \u001b[0mstr\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m4\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    248\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mF:\\Python\\jupyter\\Third_week_homework\\planar_utils.py\u001b[0m in \u001b[0;36mplot_decision_boundary\u001b[1;34m(model, X, y)\u001b[0m\n\u001b[0;32m     19\u001b[0m     \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mylabel\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'x2'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     20\u001b[0m     \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mxlabel\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'x1'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 21\u001b[1;33m     \u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mscatter\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mX\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m:\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mX\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m:\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mc\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0my\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mcmap\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mplt\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mcm\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mSpectral\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     22\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     23\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\pyplot.py\u001b[0m in \u001b[0;36mscatter\u001b[1;34m(x, y, s, c, marker, cmap, norm, vmin, vmax, alpha, linewidths, verts, edgecolors, data, **kwargs)\u001b[0m\n\u001b[0;32m   2862\u001b[0m         \u001b[0mvmin\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mvmin\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mvmax\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mvmax\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0malpha\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0malpha\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlinewidths\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mlinewidths\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2863\u001b[0m         verts=verts, edgecolors=edgecolors, **({\"data\": data} if data\n\u001b[1;32m-> 2864\u001b[1;33m         is not None else {}), **kwargs)\n\u001b[0m\u001b[0;32m   2865\u001b[0m     \u001b[0msci\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0m__ret\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2866\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[0m__ret\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\__init__.py\u001b[0m in \u001b[0;36minner\u001b[1;34m(ax, data, *args, **kwargs)\u001b[0m\n\u001b[0;32m   1808\u001b[0m                         \u001b[1;34m\"the Matplotlib list!)\"\u001b[0m \u001b[1;33m%\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mlabel_namer\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mfunc\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m__name__\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1809\u001b[0m                         RuntimeWarning, stacklevel=2)\n\u001b[1;32m-> 1810\u001b[1;33m             \u001b[1;32mreturn\u001b[0m \u001b[0mfunc\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0max\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1811\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1812\u001b[0m         inner.__doc__ = _add_data_doc(inner.__doc__,\n",
      "\u001b[1;32mc:\\users\\zhangqi\\appdata\\local\\programs\\python\\python37\\lib\\site-packages\\matplotlib\\axes\\_axes.py\u001b[0m in \u001b[0;36mscatter\u001b[1;34m(self, x, y, s, c, marker, cmap, norm, vmin, vmax, alpha, linewidths, verts, edgecolors, **kwargs)\u001b[0m\n\u001b[0;32m   4243\u001b[0m                         \u001b[1;34m\"acceptable for use with 'x' with size {xs}, \"\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   4244\u001b[0m                         \u001b[1;34m\"'y' with size {ys}.\"\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 4245\u001b[1;33m                         \u001b[1;33m.\u001b[0m\u001b[0mformat\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mnc\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mn_elem\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mxs\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msize\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mys\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0my\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msize\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   4246\u001b[0m                     )\n\u001b[0;32m   4247\u001b[0m                 \u001b[1;31m# Both the mapping *and* the RGBA conversion failed: pretty\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mValueError\u001b[0m: 'c' argument has 1 elements, which is not acceptable for use with 'x' with size 400, 'y' with size 400."
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from testCases import *\n",
    "import sklearn\n",
    "import sklearn.datasets\n",
    "import sklearn.linear_model\n",
    "from planar_utils import plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasets\n",
    "\n",
    "#%matplotlib inline #如果你使用用的是Jupyter Notebook的话请取消注释。\n",
    "\n",
    "np.random.seed(1) #设置一个固定的随机种子，以保证接下来的步骤中我们的结果是一致的。\n",
    "\n",
    "X, Y = load_planar_dataset()\n",
    "#plt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral) #绘制散点图\n",
    "shape_X = X.shape\n",
    "shape_Y = Y.shape\n",
    "m = Y.shape[1]  # 训练集里面的数量\n",
    "\n",
    "print (\"X的维度为: \" + str(shape_X))\n",
    "print (\"Y的维度为: \" + str(shape_Y))\n",
    "print (\"数据集里面的数据有：\" + str(m) + \" 个\")\n",
    "\n",
    "def layer_sizes(X , Y):\n",
    "    \"\"\"\n",
    "    参数：\n",
    "     X - 输入数据集,维度为（输入的数量，训练/测试的数量）\n",
    "     Y - 标签，维度为（输出的数量，训练/测试数量）\n",
    "\n",
    "    返回：\n",
    "     n_x - 输入层的数量\n",
    "     n_h - 隐藏层的数量\n",
    "     n_y - 输出层的数量\n",
    "    \"\"\"\n",
    "    n_x = X.shape[0] #输入层\n",
    "    n_h = 4 #，隐藏层，硬编码为4\n",
    "    n_y = Y.shape[0] #输出层\n",
    "\n",
    "    return (n_x,n_h,n_y)\n",
    "\n",
    "def initialize_parameters( n_x , n_h ,n_y):\n",
    "    \"\"\"\n",
    "    参数：\n",
    "        n_x - 输入节点的数量\n",
    "        n_h - 隐藏层节点的数量\n",
    "        n_y - 输出层节点的数量\n",
    "\n",
    "    返回：\n",
    "        parameters - 包含参数的字典：\n",
    "            W1 - 权重矩阵,维度为（n_h，n_x）\n",
    "            b1 - 偏向量，维度为（n_h，1）\n",
    "            W2 - 权重矩阵，维度为（n_y，n_h）\n",
    "            b2 - 偏向量，维度为（n_y，1）\n",
    "\n",
    "    \"\"\"\n",
    "    np.random.seed(2) #指定一个随机种子，以便你的输出与我们的一样。\n",
    "    W1 = np.random.randn(n_h,n_x) * 0.01\n",
    "    b1 = np.zeros(shape=(n_h, 1))\n",
    "    W2 = np.random.randn(n_y,n_h) * 0.01\n",
    "    b2 = np.zeros(shape=(n_y, 1))\n",
    "\n",
    "    #使用断言确保我的数据格式是正确的\n",
    "    assert(W1.shape == ( n_h , n_x ))\n",
    "    assert(b1.shape == ( n_h , 1 ))\n",
    "    assert(W2.shape == ( n_y , n_h ))\n",
    "    assert(b2.shape == ( n_y , 1 ))\n",
    "\n",
    "    parameters = {\"W1\" : W1,\n",
    "                  \"b1\" : b1,\n",
    "                  \"W2\" : W2,\n",
    "                  \"b2\" : b2 }\n",
    "\n",
    "    return parameters\n",
    "\n",
    "def forward_propagation( X , parameters ):\n",
    "    \"\"\"\n",
    "    参数：\n",
    "         X - 维度为（n_x，m）的输入数据。\n",
    "         parameters - 初始化函数（initialize_parameters）的输出\n",
    "\n",
    "    返回：\n",
    "         A2 - 使用sigmoid()函数计算的第二次激活后的数值\n",
    "         cache - 包含“Z1”，“A1”，“Z2”和“A2”的字典类型变量\n",
    "     \"\"\"\n",
    "    W1 = parameters[\"W1\"]\n",
    "    b1 = parameters[\"b1\"]\n",
    "    W2 = parameters[\"W2\"]\n",
    "    b2 = parameters[\"b2\"]\n",
    "    #前向传播计算A2\n",
    "    Z1 = np.dot(W1 , X) + b1\n",
    "    A1 = np.tanh(Z1)\n",
    "    Z2 = np.dot(W2 , A1) + b2\n",
    "    A2 = sigmoid(Z2)\n",
    "    #使用断言确保我的数据格式是正确的\n",
    "    assert(A2.shape == (1,X.shape[1]))\n",
    "    cache = {\"Z1\": Z1,\n",
    "             \"A1\": A1,\n",
    "             \"Z2\": Z2,\n",
    "             \"A2\": A2}\n",
    "\n",
    "    return (A2, cache)\n",
    "\n",
    "def compute_cost(A2,Y,parameters):\n",
    "    \"\"\"\n",
    "    计算方程（6）中给出的交叉熵成本，\n",
    "\n",
    "    参数：\n",
    "         A2 - 使用sigmoid()函数计算的第二次激活后的数值\n",
    "         Y - \"True\"标签向量,维度为（1，数量）\n",
    "         parameters - 一个包含W1，B1，W2和B2的字典类型的变量\n",
    "\n",
    "    返回：\n",
    "         成本 - 交叉熵成本给出方程（13）\n",
    "    \"\"\"\n",
    "\n",
    "    m = Y.shape[1]\n",
    "    W1 = parameters[\"W1\"]\n",
    "    W2 = parameters[\"W2\"]\n",
    "\n",
    "    #计算成本\n",
    "    logprobs = logprobs = np.multiply(np.log(A2), Y) + np.multiply((1 - Y), np.log(1 - A2))\n",
    "    cost = - np.sum(logprobs) / m\n",
    "    cost = float(np.squeeze(cost))\n",
    "\n",
    "    assert(isinstance(cost,float))\n",
    "\n",
    "    return cost\n",
    "\n",
    "def backward_propagation(parameters,cache,X,Y):\n",
    "    \"\"\"\n",
    "    使用上述说明搭建反向传播函数。\n",
    "\n",
    "    参数：\n",
    "     parameters - 包含我们的参数的一个字典类型的变量。\n",
    "     cache - 包含“Z1”，“A1”，“Z2”和“A2”的字典类型的变量。\n",
    "     X - 输入数据，维度为（2，数量）\n",
    "     Y - “True”标签，维度为（1，数量）\n",
    "\n",
    "    返回：\n",
    "     grads - 包含W和b的导数一个字典类型的变量。\n",
    "    \"\"\"\n",
    "    m = X.shape[1]\n",
    "\n",
    "    W1 = parameters[\"W1\"]\n",
    "    W2 = parameters[\"W2\"]\n",
    "\n",
    "    A1 = cache[\"A1\"]\n",
    "    A2 = cache[\"A2\"]\n",
    "\n",
    "    dZ2= A2 - Y\n",
    "    dW2 = (1 / m) * np.dot(dZ2, A1.T)\n",
    "    db2 = (1 / m) * np.sum(dZ2, axis=1, keepdims=True)\n",
    "    dZ1 = np.multiply(np.dot(W2.T, dZ2), 1 - np.power(A1, 2))\n",
    "    dW1 = (1 / m) * np.dot(dZ1, X.T)\n",
    "    db1 = (1 / m) * np.sum(dZ1, axis=1, keepdims=True)\n",
    "    grads = {\"dW1\": dW1,\n",
    "             \"db1\": db1,\n",
    "             \"dW2\": dW2,\n",
    "             \"db2\": db2 }\n",
    "\n",
    "    return grads\n",
    "\n",
    "def update_parameters(parameters,grads,learning_rate=1.2):\n",
    "    \"\"\"\n",
    "    使用上面给出的梯度下降更新规则更新参数\n",
    "\n",
    "    参数：\n",
    "     parameters - 包含参数的字典类型的变量。\n",
    "     grads - 包含导数值的字典类型的变量。\n",
    "     learning_rate - 学习速率\n",
    "\n",
    "    返回：\n",
    "     parameters - 包含更新参数的字典类型的变量。\n",
    "    \"\"\"\n",
    "    W1,W2 = parameters[\"W1\"],parameters[\"W2\"]\n",
    "    b1,b2 = parameters[\"b1\"],parameters[\"b2\"]\n",
    "\n",
    "    dW1,dW2 = grads[\"dW1\"],grads[\"dW2\"]\n",
    "    db1,db2 = grads[\"db1\"],grads[\"db2\"]\n",
    "\n",
    "    W1 = W1 - learning_rate * dW1\n",
    "    b1 = b1 - learning_rate * db1\n",
    "    W2 = W2 - learning_rate * dW2\n",
    "    b2 = b2 - learning_rate * db2\n",
    "\n",
    "    parameters = {\"W1\": W1,\n",
    "                  \"b1\": b1,\n",
    "                  \"W2\": W2,\n",
    "                  \"b2\": b2}\n",
    "\n",
    "    return parameters\n",
    "\n",
    "def nn_model(X,Y,n_h,num_iterations,print_cost=False):\n",
    "    \"\"\"\n",
    "    参数：\n",
    "        X - 数据集,维度为（2，示例数）\n",
    "        Y - 标签，维度为（1，示例数）\n",
    "        n_h - 隐藏层的数量\n",
    "        num_iterations - 梯度下降循环中的迭代次数\n",
    "        print_cost - 如果为True，则每1000次迭代打印一次成本数值\n",
    "\n",
    "    返回：\n",
    "        parameters - 模型学习的参数，它们可以用来进行预测。\n",
    "     \"\"\"\n",
    "\n",
    "    np.random.seed(3) #指定随机种子\n",
    "    n_x = layer_sizes(X, Y)[0]\n",
    "    n_y = layer_sizes(X, Y)[2]\n",
    "\n",
    "    parameters = initialize_parameters(n_x,n_h,n_y)\n",
    "    W1 = parameters[\"W1\"]\n",
    "    b1 = parameters[\"b1\"]\n",
    "    W2 = parameters[\"W2\"]\n",
    "    b2 = parameters[\"b2\"]\n",
    "\n",
    "    for i in range(num_iterations):\n",
    "        A2 , cache = forward_propagation(X,parameters)\n",
    "        cost = compute_cost(A2,Y,parameters)\n",
    "        grads = backward_propagation(parameters,cache,X,Y)\n",
    "        parameters = update_parameters(parameters,grads,learning_rate = 0.5)\n",
    "\n",
    "        if print_cost:\n",
    "            if i%1000 == 0:\n",
    "                print(\"第 \",i,\" 次循环，成本为：\"+str(cost))\n",
    "    return parameters\n",
    "\n",
    "def predict(parameters,X):\n",
    "    \"\"\"\n",
    "    使用学习的参数，为X中的每个示例预测一个类\n",
    "\n",
    "    参数：\n",
    "        parameters - 包含参数的字典类型的变量。\n",
    "        X - 输入数据（n_x，m）\n",
    "\n",
    "    返回\n",
    "        predictions - 我们模型预测的向量（红色：0 /蓝色：1）\n",
    "\n",
    "     \"\"\"\n",
    "    A2 , cache = forward_propagation(X,parameters)\n",
    "    predictions = np.round(A2)\n",
    "\n",
    "    return predictions\n",
    "\n",
    "parameters = nn_model(X, Y, n_h = 4, num_iterations=10000, print_cost=True)\n",
    "\n",
    "#绘制边界\n",
    "plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y)\n",
    "plt.title(\"Decision Boundary for hidden layer size \" + str(4))\n",
    "\n",
    "predictions = predict(parameters, X)\n",
    "print ('准确率: %d' % float((np.dot(Y, predictions.T) + np.dot(1 - Y, 1 - predictions.T)) / float(Y.size) * 100) + '%')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a\n"
     ]
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
